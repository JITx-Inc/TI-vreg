; This file is generated based on the parts database query below:")
;   database-part(["manufacturer" => "Texas Instruments", "mpn" => "TPS62933DRLR"])
#use-added-syntax(jitx)
defpackage TI-vreg/components/TPS6293x :
  import core
  import jitx
  import jitx/commands
  import ocdb/utils/generic-components
  import ocdb/utils/box-symbol
  import math

  import jsl/errors


public pcb-enum TI-vreg/components/TPS6293x/TPS6293xOptions:
  TPS6293x-PG
  TPS6293x-SS

public pcb-component component (pn:String, opt:TPS6293xOptions):
  description = "Step-down type Adjustable 3.8V~30V 3A 0.8V~22V SOT-583  DC-DC Converters ROHS"
  manufacturer = "Texas Instruments"
  mpn = pn
  datasheet = "https://www.ti.com/lit/ds/symlink/tps62932.pdf"
  pin-properties :
    [pin:Ref | pads:Ref ... | side:Dir ]
    [VIN | p[3] | Left ]
    [EN | p[2] | Left ]
    if opt == TPS6293x-PG:
      [PG | p[7] | Left ]
    else if ( opt == TPS6293x-SS ):
      [SS | p[7] | Left ]
    else:
      throw $ ValueError("Unhandled Option: %_" % [opt])
    [SS | p[7] | Left ]
    [RT | p[1] | Left ]
    [BST | p[6] | Right ]
    [SW | p[5] | Right ]
    [FB | p[8] | Right ]
    [GND | p[4] | Right ]

  assign-landpattern(lp)
  make-box-symbol()

  property(self.VIN.power-pin) = ocdb/utils/property-structs/PowerPin(min-max(3.8, 30.0))

  property(self.category) = "power_supply_chip"
  property(self.manufacturer_aliases) = ["Texas Instruments"]
  property(self.mpn_aliases) = ["TPS62933DRLR"]
  property(self.reference_prefix) = "U"
  property(self.trust) = "low"
  property(self.x) = 1.280
  property(self.y) = 2.286
  property(self.area) = 2.926
  property(self.case) = "SOT-583"

public pcb-module module (-- output-voltage:Double = 3.3 input-voltage:Double = 25.0, soft-start:Double = 2.0e-3, output-current:Double = 3.0, ripple:Double = 30.0e-3, placed:True|False = false):
  pin vin
  pin vout
  pin gnd
  pin pg
  pin en


  inst buck : components/Texas-Instruments/TPS62933DRLR/component
  net (vin, buck.VIN)
  net (en buck.EN)
  net (pg buck.SS)
  
  net GND (buck.GND gnd)
  val RT-res = res-strap(buck.RT, gnd, 0.0) ; 1.2MHz switchinglo

  inst feedback : ocdb/modules/passive-circuits/voltage-divider(source-voltage = typ(output-voltage),  
                                                                divider-output = 0.8 +/- (3 %), 
                                                                current = 0.800 / 10.0e3)

  net (feedback.in vout)
  net (feedback.out buck.FB)
  net (feedback.lo gnd)

  ; no-connect(buck.EN) ; enabled by default

  val css = soft-start * 5.5e-6 / 0.8 ; 2ms soft start
  val c-ss = cap-strap(buck.SS, gnd, closest-std-val(css, 10.0))

  val bst-params = ["capacitance" => 0.1e-6 "min-rated-voltage" => 16.0 "temperature-coefficient.code" => "X7R" ]

  inst cbst : ceramic-cap(bst-params)
  net (cbst.p[1], buck.SW)
  val r-bst = res-strap(cbst.p[2] buck.BST, 2.7) ; resistance smaller than 10 Î© be used between BST to the bootstrap capacitor.

  ; Inductor
  val fsw  = 1.2e6
  val K = (40 %)
  val L = closest-std-val(output-voltage / input-voltage * (input-voltage - output-voltage) / (fsw * K * output-current), 20.0)
  val ripple-current = output-voltage / input-voltage * (input-voltage - output-voltage) / (fsw * L)
  val peak-current = output-current + ripple-current / 2.
  val rms-current = pow( pow(output-current, 2.0) + pow(ripple-current, 2.0) / 12.0, 0.5)

  ; Ripple current < 0.1 * rated inductor current
  println("Inductor: L: %_H, Ripple: %_A, Peak : %_A" % [L, ripple-current, peak-current]) ; Would love to send these to a parametric inductor.
  inst inductor : database-part(["mpn" => "WPN4020H6R8MT", "manufacturer" => "Sunlord"])
  net (inductor.p[1] buck.SW)
  net (inductor.p[2] vout)

  ; Output capacitance
  val D = output-voltage / input-voltage
  val cout-min = ripple-current / (fsw * ripple * K) * ((1. - D) * (1. + 1.0 * K) + pow(1.0 * K, 2.) / 12.0 * (2. - D))
  ; Turns out derating is going to be datasheet-dependent - what a mess.
  val derated-capacitance = cout-min * 3. ; Arbitrary. The world should be better than this.
  val cap = 22.0e-6  ; I choose 22uF caps
  val output-cap-params = ["capacitance" => cap, "case" => "0805" "temperature-coefficient.code" => "X7R", "min-rated-voltage" => output-voltage * 2.]
  val min-output-caps:Int = to-int(derated-capacitance / cap) + 1
  val output-caps = to-tuple $
    for i in 0 to min-output-caps seq :
      val bc = bypass-cap-strap(inductor.p[2], gnd, output-cap-params)
      bc

  ; Input capacitance - 10uF derated.
  val input-cap-params = ["capacitance" => 10.0e-6, "temperature-coefficient.code" => "X7R", "min-rated-voltage" => input-voltage * 1.5 ]
  val c-inp-reg-1 = bypass-cap-strap(buck.VIN, gnd, input-cap-params)
  val c-inp-reg-2 = bypass-cap-strap(buck.VIN, gnd, input-cap-params)
  val c-inp-sm  = bypass-cap-strap(buck.VIN, gnd, ["capacitance" => 0.1e-6, "temperature-coefficient.code" => "X7R", "min-rated-voltage" => input-voltage * 1.0])

  ; Feedforward cap
  val c-ff = cap-strap(feedback.in, feedback.out, 100.0e-12) ; 100pf because I wish I had a working simulation.

  property(vout.voltage) = typ(output-voltage)

  ; placement 
  if placed :
    place(buck) at loc(0.0, 0.0, 180.0) on Top
    place(RT-res) at loc(-1.547, 1.9727, 180.0) on Top
    place(feedback.r-lo) at loc(1.475, 1.920, 180.0) on Top
    place(feedback.r-hi) at loc(2.452, 1.920) on Top
    place(c-ss) at loc(1.860218 0.395469 90.0) on Top
    place(cbst) at loc(3.497936 -0.597491 180.0) on Top
    place(r-bst) at loc(2.249856 -0.555152, 270.0) on Top
    place(inductor) at loc(2.592758, -3.859867, 270.0) on Top
    for (c in output-caps, i in 0 to false) do :
      place(output-caps[i]) at loc(3.786237 + to-double(i) * -1.79, -8.080, 180.0) on Top
      geom(GND) :
        via(ocdb/utils/defaults/default-via) at Point(3.786237 + to-double(i) * -1.79, -10.0)

    place(c-inp-reg-1) at loc(-3.565656 -2.036099 180.0) on Top
    place(c-inp-reg-2) at loc(-6.099985 -2.036099 180.0) on Top
    place(c-inp-sm) at loc(-1.770369 -0.807124 180.0) on Top
    place(c-ff) at loc(3.411575 1.927403 0.0) on Top